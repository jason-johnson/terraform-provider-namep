---
page_title: "namestring function - terraform-provider-namep"
subcategory: ""
description: |-
  This function creates a name for any terraform resource or field.
  The resulting format will be used based on the the resource type selected and the configuration.  This allows users to create conventions for the names of all resources.
---

# namestring (function)

This function creates a name for any terraform resource or field.
					  The resulting format will be used based on the the resource type selected and the configuration.  This allows users to create conventions for the names of all resources.

## Function Signature

<!-- signature generated by tfplugindocs -->
```text
namestring(resource_type string, configurations object, overrides map of string...) string
```

## Arguments

<!-- arguments generated by tfplugindocs -->
1. `resource_type` (String) Type of resource to create a name for (required for selecting format, certain variables and perform validation)
1. `configurations` (Object) A configuration object that contains the variables and formats to use for the name.

## Optional Arguments

<!-- variadic argument generated by tfplugindocs -->
1. `overrides` (Variadic, Map of String) Variable overrides.  Each argument will be processed in order, overriding the `variables` map which was passed in the configuration parameter.

## Example Usage

```terraform
data "namep_azure_locations" "example" {}

data "namep_azure_caf_types" "example" {}

data "namep_configuration" "example" {
  variable_maps = data.namep_azure_locations.example.location_maps
  types         = data.namep_azure_caf_types.example.types
  formats = {
    azure_dashes_subscription = "#{SLUG}-#{APP}-#{env}-#{LOCS[LOC]}-#{NAME}#{-SALT}"
  }

  variables = {
    name = "main"
    env  = "dev"
    app  = "myapp"
    salt = "uxx1"
    loc  = "westeurope"
  }
}

output "test" {
  value = provider::namep::namestring("azurerm_resource_group", data.namep_configuration.example.configuration, { name = "other" })
}
```

## Configuration

The configuration for the `namestring` function is most commonly created by the data source `namep_configuration`.  It can also be manually created and has the type shown by the `config` variable below.

```terraform
variable "config" {
  type = object({
    variables     = map(string)
    variable_maps = map(map(string))
    formats       = map(string)
    types = map(object({
      name             = string
      slug             = string
      min_length       = number
      max_length       = number
      lowercase        = bool
      validation_regex = string
      default_selector = string
    }))
  })
}
```

The components of the configuration are: 

## Variables

This is a map of names to their values.  These names can be used directly in the `format` string via the interpolation syntax to substitute the value in the computed name.  These values are generally provided by the user, typically via the `variables`field 
in the `namep_configuration` data source.  All variable names are case insensitive.  Entries in this map can be overridden by the `overrides` function argument.

## Variable Maps

This is a map of maps of variables to their values.  These maps can be used via the interpolation syntax `#{mapname[varname]}` to substitute the value in the computed name.  These values may be provided by the user, typically via the `variable_maps` field
in the `namep_configuration` data source, but the most common source for `variable_maps` is a "locations" data source (e.g. `namep_azure_locations`).  All variable names are case insensitive.

Note the variable name inside the map (`varname` above) needs to be a variable that exists in the `variables` map.  It cannot be a literal string value.

### Types

This is a map of the types which are selected by the `resource_type` function argument to select information about this type.  This information is used to provide values to `format` variables like `slug`.  It also enables validation of the final
computed name to detect invalid names as early in the terraform cycle as possible.  Usually this validation can already occur during the plan.  Finally, this type is used to locate the `default_selector` in the case that a specific `resource_type`
is not specified in the `format` map.  In this case, the `default_selector` is used to locate the `format` which is used to create the computed name.

This map is generally provided by a "types" data source (e.g. `namep_azure_caf_types`).  Refer to these for the types of `default_selector` values you can use from the types provided.


### Formats

This is the map of formats to use to create the computed string.  The format will be selected by the passed `resource_type` argument and `default_selector` as described in the next section.  Formats are provided by the user, often via the
`namep_configuration` data source.

The string of the finally selected `formats` entry will be converted using simple interpolation rules.  Any normal text found in the string will be left as-is.  Any text start surrounded by `#{}` will
be treated as a variable and substituted if possible.  Variables also support **optional dashes**. A variable like `#{-VAR}`
will put a dash in front of the variable unless the value is empty.  The dash can also be after the variable name to optionally
put it behind the variable instead. Using the dash on both sides is not supported.

### Format Resolution

The steps that a format are selected are:
1. Check the `types` map for an entry for the `resource_type` function argument
2. If none are found, `default_selector` will be set to "custom"
3. Check the `formats` map for an entry for the `resource_type` function argument
4. If none are found, check the `formats` map for an entry for the `default_selector` from the `types` map
5. If the value from the previous step is not found in the `formats` map, the value will split on "_" and the last part removed (e.g. "one_two_three" will become "one_two").  If there are no more parts, the function will fail.
6. Check the new value from the previous step in the `formats` map, if not found, go to step 5

This behavior will usually allow the user to only need to specify very few formats based on `default_selector` and only provide specific `resource_type` formats in the case of an override in the normal convention.

## Plan Time Resolution

It is desirable, when possible, to compute names at plan time.  For cloud systems like Azure, the name of a resource is its "key" and changing it will cause the resource to be recreated.  Unfortunately, this will also happen if the name cannot be known at 
plan time.  Things that will hinder this are reliance on values that cannot, themselves, be known at plan time.  For example, if you have a variable `SALT` which is set to be the results of a `random_string` resource, `namestring` cannot compute any name which 
uses the `SALT` variable at plan time.  These names will display "(known after apply)" in the plan output and will potentially cause the resource to be recreated.  On later runs, after the `random_string` resource has been created, the name will be known and
the name will be computed at plan time as normal.  Note: simply having a variable in the `variables` map that cannot be known at plan time will only affect names that rely on that variable.  Other names will be computed at plan time as normal.

## Unknown Values Strategy

With the current version of this provider, if any value in the configuration is not known at plan time (e.g. the `random_string` mentioned above) the entire configuration will be unknown at plan time.  This means **no names** will be known at plan time, even
those which do not use the unknown value.  We hope this limitation of the provider can be addressed in future versions.  To work around this, you can use a strategy like this:

```terraform
resource "random_string" "rnd" {
  length  = 4
  special = false
  upper   = false
}

data "namep_azure_locations" "example" {}

data "namep_azure_caf_types" "example" {}

data "namep_configuration" "example" {
  variable_maps = data.namep_azure_locations.example.location_maps
  types         = data.namep_azure_caf_types.example.types
  formats = {
    azure_dashes_subscription = "#{SLUG}-#{APP}-#{env}-#{LOCS[LOC]}-#{NAME}#{-SALT}"
  }

  variables = {
    name = "main"
    env  = "dev"
    app  = "myapp"
    salt = "NOT SET"
    loc  = "westeurope"
  }
}

output "test" {
  value = provider::namep::namestring("azurerm_resource_group", data.namep_configuration.example.configuration, { salt = random_string.rnd.result })
}
```

This way, any resources in your configuration that rely on the unknown value will crash at plan time because "NOT SET" should be invalid in any name.  For each such resource, an override can be used as shown in the output `test`.  This way, only
resources that depend on the random string will use it and be delayed and all other names can be computed at plan time.